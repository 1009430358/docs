#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-08-20 19:13-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/capped-collections.txt:3
msgid "Capped Collections"
msgstr "限制集"

#: ../source/core/capped-collections.txt:16
msgid ""
":term:`Capped collections <capped collection>` are fixed-size collections "
"that support high-throughput operations that insert and retrieve documents "
"based on insertion order. Capped collections work in a way similar to "
"circular buffers: once a collection fills its allocated space, it makes room"
" for new documents by overwriting the oldest documents in the collection."
msgstr ""

#: ../source/core/capped-collections.txt:23
msgid ""
"See :method:`~db.createCollection()` or :dbcommand:`create` for more "
"information on creating capped collections."
msgstr ""
":term:`限制集 <capped collection>` 是固定大小的集合"
"支持基于文档插入顺序的高吞吐率的插入、检索、删除操作。"
"限制收集工作在某种程度上类似于循环缓冲区：一旦一个文档填满分配给它的空间，"
"他将通过在限制集中重写老文档来给新文档让出空间"


#: ../source/core/capped-collections.txt:44

msgid ""
"For example, the :term:`oplog.rs <oplog>` collection that stores a log of "
"the operations in a :term:`replica set` uses a capped collection. Consider "
"the following potential use cases for capped collections:"
msgstr ""
"例如，:term:`oplog.rs <oplog>` 集合用一个限制集存储一个在复制集上的操作日志。"
"考虑下边限制集的潜在应用案例："

#: ../source/core/capped-collections.txt:49
msgid ""
"Store log information generated by high-volume systems. Inserting documents "
"in a capped collection without an index is close to the speed of writing log"
" information directly to a file system. Furthermore, the built-in *first-in-"
"first-out* property maintains the order of events, while managing storage "
"use."
msgstr ""
"存储高容量系统生成的日志信息。没有索引的情况下向限制集中插入文档的速度"
"接近于直接在文件系统中写日志的速度。此外，内建的*fisrt-in-first-out*特性"
"在管理存储使用时维护了事件的顺序。"

#: ../source/core/capped-collections.txt:55
msgid ""
"Cache small amounts of data in a capped collections. Since caches are read "
"rather than write heavy, you would either need to ensure that this "
"collection *always* remains in the working set (i.e. in RAM) *or* accept "
"some write penalty for the required index or indexes."
msgstr ""
"在限制集中缓存少量的数据。既然缓存是读远大于写，因此或者确保集合经常驻留"
"在工作集(i.e. in RAM)，或者接受一些需要索引的写惩罚"


#: ../source/core/capped-collections.txt:95

msgid "You cannot shard a capped collection."
msgstr "你不能对限制集分片"


#: ../source/core/capped-collections.txt:100

msgid ""
"Use natural ordering to retrieve the most recently inserted elements from "
"the collection efficiently. This is (somewhat) analogous to tail on a log "
"file."
msgstr ""
"用自然顺序检索限制集中大部分最近插入的文档。这类似于跟踪日志文件。"

#: ../source/core/capped-collections.txt:107
msgid ""
"The aggregation pipeline operator :pipeline:`$out` cannot write results to a"
" capped collection."
msgstr ""
"聚合管道操作:pipeline:`$out`不能写结果到限制集中"

#: ../source/core/capped-collections.txt:113
msgid "Procedures"
msgstr "程序"

#: ../source/core/capped-collections.txt:116
msgid "Create a Capped Collection"
msgstr "创建一个限制集"



#: ../source/core/capped-collections.txt:130
msgid ""
"If the ``size`` field is less than or equal to 4096, then the collection "
"will have a cap of 4096 bytes. Otherwise, MongoDB will raise the provided "
"size to make it an integer multiple of 256."
msgstr ""

#: ../source/core/capped-collections.txt:134
msgid ""
"Additionally, you may also specify a maximum number of documents for the "
"collection using the ``max`` field as in the following document:"
msgstr ""
"另外，你可以为限制集指定最大文档数据，用 ``max`` 字段就像下边的文档："

#: ../source/core/capped-collections.txt:141
msgid ""
"The ``size`` argument is *always* required, even when you specify ``max`` "
"number of documents. MongoDB will remove older documents if a collection "
"reaches the maximum size limit before it reaches the maximum document count."
msgstr ""
" ``size`` 参数经常是需要的，甚至当你指定 ``max`` 文档个数时。"
"MongoDB在尺寸达到最大限制时即使没有到达最大文档数限制也将移除旧文档。"

#: ../source/core/capped-collections.txt:0
msgid "See"
msgstr "见"

#: ../source/core/capped-collections.txt:151
msgid "Query a Capped Collection"
msgstr "查询一个限制集"

#: ../source/core/capped-collections.txt:153
msgid ""
"If you perform a :method:`~db.collection.find()` on a capped collection with"
" no ordering specified, MongoDB guarantees that the ordering of results is "
"the same as the insertion order."
msgstr ""
"如果你在限制集上执行一个没有指定排序的 :method:`~db.collection.find()` 方法，"
"MongoDB保证结果的顺序是和插入顺序相同。"

#: ../source/core/capped-collections.txt:157
msgid ""
"To retrieve documents in reverse insertion order, issue "
":method:`~db.collection.find()` along with the :method:`~cursor.sort()` "
"method with the :operator:`$natural` parameter set to ``-1``, as shown in "
"the following example:"
msgstr ""
"用同插入相反的顺序检索文档， :method:`~db.collection.find()` 连同"
" :method:`~cursor.sort()` 方法，及 :operator:`$natural` 参数设置为 ``-1`` 就像下面的例子："

#: ../source/core/capped-collections.txt:167
msgid "Check if a Collection is Capped"
msgstr "检查一个集合是否是限制集"

#: ../source/core/capped-collections.txt:169
msgid ""
"Use the :method:`~db.collection.isCapped()` method to determine if a "
"collection is capped, as follows:"
msgstr ""
"用 :method:`~db.collection.isCapped()` 方法来判定一个集合是否是限制集，如下："

#: ../source/core/capped-collections.txt:177
msgid "Convert a Collection to Capped"
msgstr "转换为限制集"

#: ../source/core/capped-collections.txt:179
msgid ""
"You can convert a non-capped collection to a capped collection with the "
":dbcommand:`convertToCapped` command:"
msgstr ""
"你可以用命令 :dbcommand:`convertToCapped` 转换一个非限制集成为一个限制集："

#: ../source/core/capped-collections.txt:186
msgid ""
"The ``size`` parameter specifies the size of the capped collection in bytes."
msgstr ""
"``size``参数用bytes指定限制集及的大小。"

#: ../source/includes/warning-blocking-global.rst:3
msgid ""
"This command obtains a global write lock and will block other operations "
"until it has completed."
msgstr ""
"这个命令将获得一个全局写锁并将阻塞其他操作，直到它完成为止。"


#: ../source/core/capped-collections.txt:192

msgid "Automatically Remove Data After a Specified Period of Time"
msgstr "在规定的时间周期之后将自动移除数据"

#: ../source/core/capped-collections.txt:194
msgid ""
"For additional flexibility when expiring data, consider MongoDB's "
":term:`TTL` indexes, as described in :doc:`/tutorial/expire-data`. These "
"indexes allow you to expire and remove data from normal collections using a "
"special type, based on the value of a date-typed field and a TTL value for "
"the index."
msgstr ""
"当数据到期时对于另外的灵活性，考虑MongodDB的 :term:`TTL` 索引，就像在"
" :doc:`/tutorial/expire-data` 中描述的。"

#: ../source/core/capped-collections.txt:200
msgid ""
":doc:`TTL Collections </tutorial/expire-data>` are not compatible with "
"capped collections."
msgstr ""
":doc:`TTL Collections </tutorial/expire-data>` 与限制集不兼容。"

#: ../source/core/capped-collections.txt:204
msgid "Tailable Cursor"
msgstr "Tailable游标"

#: ../source/core/capped-collections.txt:206
msgid ""
"You can use a :term:`tailable cursor` with capped collections. Similar to "
"the Unix ``tail -f`` command, the tailable cursor \"tails\" the end of a "
"capped collection. As new documents are inserted into the capped collection,"
" you can use the tailable cursor to continue retrieving documents."
msgstr ""
"你可以用 :term:`tailable cursor` 与限制集。同unix中的 ``tail -f`` 命令相似，"
" tailable光标 \"tails\" 一个限制集的结尾。随着新文档被插入到限制集，你能用"
" tailable光标来继续检索文档。"

#: ../source/core/capped-collections.txt:0
msgid "On this page"
msgstr ""

#: ../source/core/capped-collections.txt:14
msgid "Overview"
msgstr ""

#: ../source/core/capped-collections.txt:27
msgid "Behavior"
msgstr ""

#: ../source/core/capped-collections.txt:30
msgid "Insertion Order"
msgstr ""

#: ../source/core/capped-collections.txt:32
msgid ""
"Capped collections guarantee preservation of the insertion order. As a "
"result, queries do not need an index to return documents in insertion order."
" Without this indexing overhead, capped collections can support higher "
"insertion throughput."
msgstr ""

#: ../source/core/capped-collections.txt:38
msgid "Automatic Removal of Oldest Documents"
msgstr ""

#: ../source/core/capped-collections.txt:40
msgid ""
"To make room for new documents, capped collections automatically remove the "
"oldest documents in the collection without requiring scripts or explicit "
"remove operations."
msgstr ""

#: ../source/core/capped-collections.txt:62
msgid "``_id`` Index"
msgstr ""

#: ../source/core/capped-collections.txt:64
msgid ""
"Capped collections have an ``_id`` field and an index on the ``_id`` field "
"by default."
msgstr ""

#: ../source/core/capped-collections.txt:70
msgid "Restrictions and Recommendations"
msgstr ""

#: ../source/core/capped-collections.txt:73
msgid "Updates"
msgstr ""

#: ../source/core/capped-collections.txt:75
msgid ""
"If you plan to update documents in a capped collection, create an index so "
"that these update operations do not require a collection scan."
msgstr ""

#: ../source/core/capped-collections.txt:79
msgid "Document Size"
msgstr ""

#: ../source/includes/extracts/capped-collection-immutable-document-size.rst:1
msgid ""
"If an update or a replacement operation changes the document size, the "
"operation will fail."
msgstr ""

#: ../source/core/capped-collections.txt:86
msgid "Document Deletion"
msgstr ""

#: ../source/core/capped-collections.txt:88
msgid ""
"You cannot delete documents from a capped collection. To remove all "
"documents from a collection, use the :method:`~db.collection.drop()` method "
"to drop the collection and recreate the capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:93
msgid "Sharding"
msgstr ""

#: ../source/core/capped-collections.txt:98
msgid "Query Efficiency"
msgstr ""

#: ../source/core/capped-collections.txt:105
msgid "Aggregation ``$out``"
msgstr ""

#: ../source/core/capped-collections.txt:118
msgid ""
"You must create capped collections explicitly using the "
":method:`db.createCollection()` method, which is a helper in the "
":program:`mongo` shell for the :dbcommand:`create` command. When creating a "
"capped collection you must specify the maximum size of the collection in "
"bytes, which MongoDB will pre-allocate for the collection. The size of the "
"capped collection includes a small amount of space for internal overhead."
msgstr ""

#: ../source/core/capped-collections.txt:212
msgid ""
"See :doc:`/core/tailable-cursors` for information on creating a tailable "
"cursor."
msgstr ""

#~ msgid "Capped collections have the following behaviors:"
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee preservation of the insertion order. As a "
#~ "result, queries do not need an index to return documents in insertion order."
#~ " Without this indexing overhead, they can support higher insertion "
#~ "throughput."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee that insertion order is identical to the order "
#~ "on disk (:term:`natural order`) and do so by prohibiting updates that "
#~ "increase document size. Capped collections only allow updates that fit the "
#~ "original document size, which ensures a document does not change its "
#~ "location on disk."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections automatically remove the oldest documents in the "
#~ "collection without requiring scripts or explicit remove operations."
#~ msgstr ""

#~ msgid "Recommendations and Restrictions"
#~ msgstr ""

#~ msgid ""
#~ "You can only make in-place updates of documents. If the update operation "
#~ "causes the document to grow beyond their original size, the update operation"
#~ " will fail."
#~ msgstr ""

#~ msgid ""
#~ "If you plan to update documents in a capped collection, create an index so "
#~ "that these update operations do not require a table scan."
#~ msgstr ""

#~ msgid ""
#~ "If you update a document in a capped collection to a size smaller than its "
#~ "original size, and then a secondary resyncs from the primary, the secondary "
#~ "will replicate and allocate space based on the current smaller document "
#~ "size. If the primary then receives an update which increases the document "
#~ "back to its original size, the primary will accept the update but the "
#~ "secondary will fail with a ``failing update: objects in a capped ns cannot "
#~ "grow`` error message."
#~ msgstr ""

#~ msgid ""
#~ "To prevent this error, create your secondary from a snapshot of one of the "
#~ "other up-to-date members of the replica set. Follow :doc:`our tutorial on "
#~ "filesystem snapshots </tutorial/backup-with-filesystem-snapshots>` to seed "
#~ "your new secondary."
#~ msgstr ""

#~ msgid ""
#~ "Seeding the secondary with a filesystem snapshot is the only way to "
#~ "guarantee the primary and secondary binary files are compatible. |MMS| "
#~ "Backup snapshots are insufficient in this situation since you need more than"
#~ " the content of the secondary to match the primary."
#~ msgstr ""

#~ msgid ""
#~ "You cannot delete documents from a capped collection.  To remove all "
#~ "documents from a collection, use the :method:`~db.collection.drop()` method "
#~ "to drop the collection."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections created after 2.2 have an ``_id`` field and an index on "
#~ "the ``_id`` field by default. Capped collections created before 2.2 do not "
#~ "have an index on the ``_id`` field by default. If you are using capped "
#~ "collections with replication prior to 2.2, you should explicitly create an "
#~ "index on the ``_id`` field."
#~ msgstr ""

#~ msgid ""
#~ "If you have a capped collection in a :term:`replica set` outside of the "
#~ "``local`` database, before 2.2, you should create a unique index on ``_id``."
#~ " Ensure uniqueness using the ``unique: true`` option to the "
#~ ":method:`~db.collection.createIndex()` method or by using an "
#~ ":term:`ObjectId` for the ``_id`` field. Alternately, you can use the "
#~ "``autoIndexId`` option to :dbcommand:`create` when creating the capped "
#~ "collection, as in the :ref:`capped-collections-options` procedure."
#~ msgstr ""

#~ msgid ""
#~ "You must create capped collections explicitly using the "
#~ ":method:`~db.createCollection()` method, which is a helper in the "
#~ ":program:`mongo` shell for the :dbcommand:`create` command. When creating a "
#~ "capped collection you must specify the maximum size of the collection in "
#~ "bytes, which MongoDB will pre-allocate for the collection. The size of the "
#~ "capped collection includes a small amount of space for internal overhead."
#~ msgstr ""

#~ msgid ""
#~ "Before 2.2, capped collections did not have an index on ``_id`` unless you "
#~ "specified ``autoIndexId`` to the :dbcommand:`create`, after 2.2 this became "
#~ "the default."
#~ msgstr ""

#~ msgid ""
#~ "See :doc:`/tutorial/create-tailable-cursor` for information on creating a "
#~ "tailable cursor."
#~ msgstr ""
