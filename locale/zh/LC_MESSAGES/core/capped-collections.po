# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2014, MongoDB, Inc.
# This file is distributed under the same license as the mongodb-manual package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: MongoDB Manual\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-08 13:03-0400\n"
"PO-Revision-Date: 2014-04-09 21:17+0000\n"
"Last-Translator: 张传美 <zcmsniper@sina.com>\n"
"Language-Team: Chinese (http://www.transifex.com/projects/p/mongodb-manual/language/zh/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# 6dc3f63dae0346cfbcea44d4c0827810
#: ../source/core/capped-collections.txt:3
msgid "Capped Collections"
msgstr "限制集"

# 147e7ea0a3c44167b39df3eea824c3fc
#: ../source/core/capped-collections.txt:7
msgid ""
":term:`Capped collections <capped collection>` are fixed-size collections "
"that support high-throughput operations that insert, retrieve, and delete "
"documents based on insertion order. Capped collections work in a way similar"
" to circular buffers: once a collection fills its allocated space, it makes "
"room for new documents by overwriting the oldest documents in the "
"collection."
msgstr ""
":term:`限制集 <capped collection>` 是固定大小的集合"
"支持基于文档插入顺序的高吞吐率的插入、检索、删除操作。"
"限制收集工作在某种程度上类似于循环缓冲区：一旦一个文档填满分配给它的空间，"
"他将通过在限制集中重写老文档来给新文档让出空间"

# ac21964830ed479db45f7ace697dbb02
#: ../source/core/capped-collections.txt:17
msgid "Capped collections have the following behaviors:"
msgstr "限制集有以下行为"

# 217720f9f2014ca19d835823fad10e75
#: ../source/core/capped-collections.txt:19
msgid ""
"Capped collections guarantee preservation of the insertion order. As a "
"result, queries do not need an index to return documents in insertion order."
" Without this indexing overhead, they can support higher insertion "
"throughput."
msgstr ""
"限制集保证了插入顺序，因此查询不需要索引来按插入的顺序返回文档。"
"没有索引开销，限制集能够支持高插入吞吐率"

# 1bb593430d52442ab7c5e47c96c23448
#: ../source/core/capped-collections.txt:24
msgid ""
"Capped collections guarantee that insertion order is identical to the order "
"on disk (:term:`natural order`) and do so by prohibiting updates that "
"increase document size. Capped collections only allow updates that fit the "
"original document size, which ensures a document does not change its "
"location on disk."
msgstr ""
"限制集保证插入顺序同在硬盘上的顺序(:term:`自然顺序`) 完全相同，通过禁止增加文档的大小来做到。"
"限制集值允许复合原始尺寸的更新，这确保了一个文档不改变它在硬盘上的位置。"

# 5ad7527aedde4028acee852a122f6426
#: ../source/core/capped-collections.txt:30
msgid ""
"Capped collections automatically remove the oldest documents in the "
"collection without requiring scripts or explicit remove operations."
msgstr ""
"限制集自动删除在集合中的老文档，不需要脚本或者显示移除操作"

# 61f4467bf003499dafd6c5078e2e6629
#: ../source/core/capped-collections.txt:33
msgid ""
"For example, the :term:`oplog.rs <oplog>` collection that stores a log of "
"the operations in a :term:`replica set` uses a capped collection. Consider "
"the following potential use cases for capped collections:"
msgstr ""
"例如，:term:`oplog.rs <oplog>` 集合用一个限制集存储一个在复制集上的操作日志。"
"考虑下边限制集的潜在应用案例："

# dfcc91c483a34408ad0a36a32b5037c1
#: ../source/core/capped-collections.txt:38
msgid ""
"Store log information generated by high-volume systems. Inserting documents "
"in a capped collection without an index is close to the speed of writing log"
" information directly to a file system. Furthermore, the built-in *first-in-"
"first-out* property maintains the order of events, while managing storage "
"use."
msgstr ""
"存储高容量系统生成的日志信息。没有索引的情况下向限制集中插入文档的速度"
"接近于直接在文件系统中写日志的速度。此外，内建的*fisrt-in-first-out*特性"
"在管理存储使用时维护了事件的顺序。"

# 55297249a2c94d3caa3f66de04d8c18d
#: ../source/core/capped-collections.txt:44
msgid ""
"Cache small amounts of data in a capped collections. Since caches are read "
"rather than write heavy, you would either need to ensure that this "
"collection *always* remains in the working set (i.e. in RAM) *or* accept "
"some write penalty for the required index or indexes."
msgstr ""
"在限制集中缓存少量的数据。既然缓存是读远大于写，因此或者确保集合经常驻留"
"在工作集(i.e. in RAM)，或者接受一些需要索引的写惩罚"

# 32a5204209894641a051a6f4e35bdfe2
#: ../source/core/capped-collections.txt:53
msgid "Recommendations and Restrictions"
msgstr "建议和限制"

# b6252b1b648d4d408eb6524d36d14a54
#: ../source/core/capped-collections.txt:59
msgid ""
"If you plan to update documents in a capped collection, create an index so "
"that these update operations do not require a table scan."
msgstr ""
"加入你计划在限制集中更新文档，那么创建一个索引，这样更新操作就不需要表级别的扫描了"

# ad7a10a56b1048bfa3c37a42418e7ea7
#: ../source/core/capped-collections.txt:80
msgid ""
"You cannot delete documents from a capped collection. To remove all records "
"from a capped collection, use the 'emptycapped' command. To remove the "
"collection entirely, use the :method:`~db.collection.drop()` method."
msgstr ""
"你不能从限制集中删除文档。用'emptycapped'命令从限制集中删除所有文档。"
"用:method:`~db.collection.drop()` 方法删除整个集合。"

# 24fd378875e043a6aedf1a3ac2071b07
#: ../source/core/capped-collections.txt:85
msgid "You cannot shard a capped collection."
msgstr "你不能对限制集分片"

# d327dfd5561a43a18328c77f16b25dcd
#: ../source/core/capped-collections.txt:87
msgid ""
"Capped collections created after 2.2 have an ``_id`` field and an index on "
"the ``_id`` field by default. Capped collections created before 2.2 do not "
"have an index on the ``_id`` field by default. If you are using capped "
"collections with replication prior to 2.2, you should explicitly create an "
"index on the ``_id`` field."
msgstr ""
"在2.2之后限制集默认情况下会创建一个``_id``字段和在``_id``字段上的索引。"
"在2.2之前限制集默认情况下没有``_id``字段上的索引。如果你在2.2之前的复制集上用限制集"
"那么你应该明确的在``_id``字段上创建索引。"

# e2c3b9520ca948a9812cad71b26e266b
#: ../source/core/capped-collections.txt:95
msgid ""
"If you have a capped collection in a :term:`replica set` outside of the "
"``local`` database, before 2.2, you should create a unique index on ``_id``."
" Ensure uniqueness using the ``unique: true`` option to the "
":method:`~db.collection.ensureIndex()` method or by using an "
":term:`ObjectId` for the ``_id`` field. Alternately, you can use the "
"``autoIndexId`` option to :dbcommand:`create` when creating the capped "
"collection, as in the :ref:`capped-collections-options` procedure."
msgstr ""
"在2.2之前，如果你有一个在``local``数据库之外的:term:`replica set`上有一个限制集，"
"你应该在字段``_id``上用:method:`~db.collection.ensureIndex()`方法的``unique: true``选项"
"来创建唯一索引或者通过在 ``_id`` 字段上用 :term:`ObjectId` 选项"

# 7537b9df519c4a598f4014b85c237c8b
#: ../source/core/capped-collections.txt:104
msgid ""
"Use natural ordering to retrieve the most recently inserted elements from "
"the collection efficiently. This is (somewhat) analogous to tail on a log "
"file."
msgstr ""
"用自然顺序检索限制集中大部分最近插入的文档。这类似于跟踪日志文件。"

# 93ff7b398ba94f8fb16af31a303f8715
#: ../source/core/capped-collections.txt:108
msgid ""
"The aggregation pipeline operator :pipeline:`$out` cannot write results to a"
" capped collection."
msgstr ""
"聚合管道操作:pipeline:`$out`不能写结果到限制集中"

# 41fa7374b8f84c04a7cf7ee2a37e4f9d
#: ../source/core/capped-collections.txt:112
msgid "Procedures"
msgstr "程序"

# b6a958ff408f45c58b7037ff81a42380
#: ../source/core/capped-collections.txt:115
msgid "Create a Capped Collection"
msgstr "创建一个限制集"

# 7a065ae7189742d29eef0edce02e743d
#: ../source/core/capped-collections.txt:117
msgid ""
"You must create capped collections explicitly using the "
":method:`~db.createCollection()` method, which is a helper in the "
":program:`mongo` shell for the :dbcommand:`create` command. When creating a "
"capped collection you must specify the maximum size of the collection in "
"bytes, which MongoDB will pre-allocate for the collection. The size of the "
"capped collection includes a small amount of space for internal overhead."
msgstr ""
"你必须用方法 :method:`~db.createCollection()` 明确创建限制集，在程序 :program:`mongo` "
"shell命令 :dbcommand:`create` 中有帮助信息。 当创建一个限制集时，"
"你必须用bytes指定这个限制集的最大尺寸，MongoDB将为这个限制集预分配一些空间。"
"限制集的大小包括少量内部开销。"

# 2240a66d853849f4a5d48a199bd0122a
#: ../source/core/capped-collections.txt:129
msgid ""
"Additionally, you may also specify a maximum number of documents for the "
"collection using the ``max`` field as in the following document:"
msgstr ""
"另外，你可以为限制集指定最大文档数据，用 ``max`` 字段就像下边的文档："

# d0f9970fd0db4d3d82aac9ec7a41e5e3
#: ../source/core/capped-collections.txt:136
msgid ""
"The ``size`` argument is *always* required, even when you specify ``max`` "
"number of documents. MongoDB will remove older documents if a collection "
"reaches the maximum size limit before it reaches the maximum document count."
msgstr ""
" ``size`` 参数经常是需要的，甚至当你指定 ``max`` 文档个数时。"
"MongoDB在尺寸达到最大限制时即使没有到达最大文档数限制也将移除旧文档。"

# 1a699cc0bba54a529981816f7a3bc64e
#: ../source/core/capped-collections.txt:0
msgid "See"
msgstr "见"

# db23bdea301d49b284756b69bb2837dc
#: ../source/core/capped-collections.txt:146
msgid "Query a Capped Collection"
msgstr "查询一个限制集"

# 8855cfbc8ec142a597203096290fe5f3
#: ../source/core/capped-collections.txt:148
msgid ""
"If you perform a :method:`~db.collection.find()` on a capped collection with"
" no ordering specified, MongoDB guarantees that the ordering of results is "
"the same as the insertion order."
msgstr ""
"如果你在限制集上执行一个没有指定排序的 :method:`~db.collection.find()` 方法，"
"MongoDB保证结果的顺序是和插入顺序相同。"

# 34034004f3c8469492fef4c90487ea07
#: ../source/core/capped-collections.txt:152
msgid ""
"To retrieve documents in reverse insertion order, issue "
":method:`~db.collection.find()` along with the :method:`~cursor.sort()` "
"method with the :operator:`$natural` parameter set to ``-1``, as shown in "
"the following example:"
msgstr ""
"用同插入相反的顺序检索文档， :method:`~db.collection.find()` 连同"
" :method:`~cursor.sort()` 方法，及 :operator:`$natural` 参数设置为 ``-1`` 就像下面的例子："

# 83578b0fc99c41a5be4e8fb691915a0d
#: ../source/core/capped-collections.txt:162
msgid "Check if a Collection is Capped"
msgstr "检查一个集合是否是限制集"

# b18ed2c4a15b4f3a88d701facfc12131
#: ../source/core/capped-collections.txt:164
msgid ""
"Use the :method:`~db.collection.isCapped()` method to determine if a "
"collection is capped, as follows:"
msgstr ""
"用 :method:`~db.collection.isCapped()` 方法来判定一个集合是否是限制集，如下："

# 0408f76d935349bda4d7a0c885f2c065
#: ../source/core/capped-collections.txt:172
msgid "Convert a Collection to Capped"
msgstr "转换为限制集"

# 39833a5e17364a778270820e733029de
#: ../source/core/capped-collections.txt:174
msgid ""
"You can convert a non-capped collection to a capped collection with the "
":dbcommand:`convertToCapped` command:"
msgstr ""
"你可以用命令 :dbcommand:`convertToCapped` 转换一个非限制集成为一个限制集："

# 8c89f3bc138a4dcfaac7df7e4d57ee54
#: ../source/core/capped-collections.txt:181
msgid ""
"The ``size`` parameter specifies the size of the capped collection in bytes."
msgstr ""
"``size``参数用bytes指定限制集及的大小。"

# ffbed2c492d24d5daf1e2575b562f0de
#: ../source/includes/warning-blocking-global.rst:3
msgid ""
"This command obtains a global write lock and will block other operations "
"until it has completed."
msgstr ""
"这个命令将获得一个全局写锁并将阻塞其他操作，直到它完成为止。"

# 7e130d78cbc04f2cbfac42c046362b87
#: ../source/core/capped-collections.txt:186
msgid ""
"Before 2.2, capped collections did not have an index on ``_id`` unless you "
"specified ``autoIndexId`` to the :dbcommand:`create`, after 2.2 this became "
"the default."
msgstr ""
"在2.2之前，限制集没有在字段 ``_id`` 上的索引，直到你指定 ``autoIndexId`` 到 :dbcommand:`create` 命令上，"
"2.2之后变为默认的了。"

# 9705682e004d43a6b9c84ab87b57ded2
#: ../source/core/capped-collections.txt:192
msgid "Automatically Remove Data After a Specified Period of Time"
msgstr "在规定的时间周期之后将自动移除数据"

# 51d586068f114791b174d423a63b278d
#: ../source/core/capped-collections.txt:194
msgid ""
"For additional flexibility when expiring data, consider MongoDB's "
":term:`TTL` indexes, as described in :doc:`/tutorial/expire-data`. These "
"indexes allow you to expire and remove data from normal collections using a "
"special type, based on the value of a date-typed field and a TTL value for "
"the index."
msgstr ""
"当数据到期时对于另外的灵活性，考虑MongodDB的 :term:`TTL` 索引，就像在"
" :doc:`/tutorial/expire-data` 中描述的。"

# 3fff5cebeb0e4b01ac1b775575ed928a
#: ../source/core/capped-collections.txt:200
msgid ""
":doc:`TTL Collections </tutorial/expire-data>` are not compatible with "
"capped collections."
msgstr ""
":doc:`TTL Collections </tutorial/expire-data>` 与限制集不兼容。"

# 2c64e5d1f9204f21b7bac515e4790f4d
#: ../source/core/capped-collections.txt:204
msgid "Tailable Cursor"
msgstr "Tailable游标"

# 254a2b382bf84a1a938e809dc870eab0
#: ../source/core/capped-collections.txt:212
msgid ""
"See :doc:`/tutorial/create-tailable-cursor` for information on creating a "
"tailable cursor."
msgstr ""
"参考文档 :doc:`/tutorial/create-tailable-cursor` 创建tailable游标。"

#: ../source/core/capped-collections.txt:14
msgid ""
"See :method:`~db.createCollection()` or :dbcommand:`create` for more "
"information on creating capped collections."
msgstr ""
"参考方法 :method:`~db.createCollection()` 或者命令 :dbcommand:`create` "
"获得创建限制集时的更多信息"

#: ../source/core/capped-collections.txt:55
msgid ""
"You can only make in-place updates of documents. If the update operation "
"causes the document to grow beyond their original size, the update operation"
" will fail."
msgstr ""
"你可以做文档的原地更新。如果此更新操作引起了文档的增长超出了他们原始尺寸，"
"那么更新操作将失败。"

#: ../source/core/capped-collections.txt:62
msgid ""
"If you update a document in a capped collection to a size smaller than its "
"original size, and then a secondary resyncs from the primary, the secondary "
"will replicate and allocate space based on the current smaller document "
"size. If the primary then receives an update which increases the document "
"back to its original size, the primary will accept the update but the "
"secondary will fail with a ``failing update: objects in a capped ns cannot "
"grow`` error message."
msgstr ""
"假如你更新一个限制集中的文档到比它原始尺寸小的大小，那么从机将从主机上同步，"
"从机将基于当前较小的文档复制并分配空间。如果主机接着收到更新操作增加文档到它原来尺寸"
"，那么主机将接受更新，但是从机将失败伴随着``failing update: objects in a capped ns cannot "
"grow`` 的错误消息。"


#: ../source/core/capped-collections.txt:70
msgid ""
"To prevent this error, create your secondary from a snapshot of one of the "
"other up-to-date members of the replica set. Follow :doc:`our tutorial on "
"filesystem snapshots </tutorial/backup-with-filesystem-snapshots>` to seed "
"your new secondary."
msgstr ""
"为避免此错误，从其他复制集成员最近一个快照创建你的从机。跟着文档 :doc:`our tutorial on "
"filesystem snapshots </tutorial/backup-with-filesystem-snapshots>` 完善你的从机。"

#: ../source/core/capped-collections.txt:75
msgid ""
"Seeding the secondary with a filesystem snapshot is the only way to "
"guarantee the primary and secondary binary files are compatible. MMS Backup "
"snapshots are insufficient in this situation since you need more than the "
"content of the secondary to match the primary."
msgstr ""
"用文件系统快照初始你的从机是保证主机和从机二进制文件完整性的唯一方法。MMS备份快照"
"在此种情况下不充分，当你需要从机不仅仅内容与主机保持一致时。"

#: ../source/core/capped-collections.txt:206
msgid ""
"You can use a :term:`tailable cursor` with capped collections. Similar to "
"the Unix ``tail -f`` command, the tailable cursor \"tails\" the end of a "
"capped collection. As new documents are inserted into the capped collection,"
" you can use the tailable cursor to continue retrieving documents."
msgstr ""
"你可以用 :term:`tailable cursor` 与限制集。同unix中的 ``tail -f`` 命令相似，"
" tailable光标 \"tails\" 一个限制集的结尾。随着新文档被插入到限制集，你能用"
" tailable光标来继续检索文档。"

#~ msgid ""
#~ "See :method:`~db.createCollection()` or :dbcommand:`createCollection` for "
#~ "more information on creating capped collections."
#~ msgstr ""

#~ msgid ""
#~ "You *can* update documents in a collection after inserting them. *However,* "
#~ "these updates **cannot** cause the documents to grow. If the update "
#~ "operation causes the document to grow beyond their original size, the update"
#~ " operation will fail."
#~ msgstr ""

#~ msgid ""
#~ "You can use a tailable cursor with capped collections. Similar to the Unix "
#~ "``tail -f`` command, the tailable cursor \"tails\" the end of a capped "
#~ "collection. As new documents are inserted into the capped collection, you "
#~ "can use the tailable cursor to continue retrieving documents."
#~ msgstr ""
